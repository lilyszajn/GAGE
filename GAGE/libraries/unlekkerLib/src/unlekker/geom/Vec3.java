package unlekker.geom;import unlekker.util.Str;/** * <p>3D vector class.</p>  * @author <a href="http://workshop.evolutionzone.com/">Marius Watz</a> */public class Vec3 { static final float DEG=(3.14159265358979323846f/180.0f); public float x,y,z; public Vec3() { } public Vec3(float x,float y,float z) {this.x=x; this.y=y; this.z=z;} public Vec3(Vec3 v) {this.x=v.x; this.y=v.y; this.z=v.z;} public boolean cmp(Vec3 v) {//  System.out.println("v=="+v+" cmp "+toString());  if(v.x-this.x==0 && v.y-this.y==0 && v.z-this.z==0) return true;  else return false; } public void set(Vec3 v) {  x=v.x; y=v.y; z=v.z; } public void set(float tx,float ty,float tz) {  x=tx; y=ty; z=tz; } public void clamp(float minx,float maxx,float miny,float maxy,  float minz,float maxz) {  if(x<minx) x=minx; else if(x>maxx) x=maxx;  if(y<miny) y=miny; else if(y>maxy) y=maxy;  if(z<minz) z=minz; else if(z>maxz) z=maxz; } public void abs() {  x=Math.abs(x);  y=Math.abs(y);  z=Math.abs(z); } public static Vec3 abs(Vec3 v) {  return new Vec3(Math.abs(v.x),Math.abs(v.y),Math.abs(v.z)); } public String toString() {  String s;  int prec=6;  s=new String("<"+Str.numStr(this.x)+","+Str.numStr(this.y)+","+Str.numStr(this.z)+">");  return s; } public String toString(int precision) {  String s;  s=new String("<"+Str.numStr(this.x)+","+   Str.numStr(this.y)+","+   Str.numStr(this.z)+">");  return s; } public void add(Vec3 v) {x+=v.x; y+=v.y; z+=v.z;} public void add(float vx,float vy,float vz) {x+=vx; y+=vy; z+=vz;} public void add(float n) {x+=n; y+=n; z+=n;} public static Vec3 add(Vec3 v1,Vec3 v2) {  return new Vec3(v1.x+v2.x,v1.y+v2.y,v1.z+v2.z); } public void sub(Vec3 v) {x-=v.x; y-=v.y; z-=v.z;} public void sub(float vx,float vy,float vz) {x-=vx; y-=vy; z-=vz;} public void sub(float n) {x-=n; y-=n; z-=n;} public static Vec3 sub(Vec3 v1,Vec3 v2) {  return new Vec3(v1.x-v2.x,v1.y-v2.y,v1.z-v2.z); } public void mult(Vec3 v) {x*=v.x; y*=v.y; z*=v.z;} public void mult(float vx,float vy,float vz) {x*=vx; y*=vy; z*=vz;} public void mult(float m) {x*=m; y*=m; z*=m;} public void div(float m) {x/=m; y/=m; z/=m;} public static Vec3 mult(Vec3 v1,Vec3 v2) {  return new Vec3(v1.x*v2.x,v1.y*v2.y,v1.z*v2.z); } public static Vec3 mult(Vec3 v,float m) {  return new Vec3(v.x*m,v.y*m,v.z*m); } public void norm() {  float l;  l=length();  if(l>0) {x/=l; y/=l; z/=l;} } public void norm(float m) {  float l;  l=length();  if(l>0) {x/=l; y/=l; z/=l;}  x*=m; y*=m; z*=m; } public void normMult(float m) {  float l;  l=length();  if(l>0) {x/=l; y/=l; z/=l;}  x*=m; y*=m; z*=m; } public void setToCrossProduct(float ax,float ay,float az,float bx,float by,float bz){   x=ay*bz-by*az;   y=az*bx-bz*ax;   z=ax*by-bx*ay; } public Vec3 cross(Vec3 v){   float crossX=y*v.z-v.y*z;   float crossY=z*v.x-v.z*x;   float crossZ=x*v.y-v.x*y;   return(new Vec3(crossX,crossY,crossZ)); } public float length() {return (float)Math.sqrt(x*x+y*y+z*z);} public static float length(Vec3 v1) {return (float)Math.sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);} public static float length(float x,float y,float z) {return (float)Math.sqrt(x*x+y*y+z*z);} public float findDistance(float _x,float _y,float _z) {   _x-=x;   _y-=y;   _z-=z;  return (float)Math.sqrt(_x*_x+_y*_y+_z*_z); } public static float distance(Vec3 v1,Vec3 v2) {  return Vec3.length(v2.x-v1.x,v2.y-v1.y,v2.z-v1.z); } public boolean equals(float tx,float ty,float tz) {  return Vec3.equals(x,y,z,tx,ty,tz); } public boolean equals(Vec3 v) {  return equals(x,y,z,v.x,v.y,v.z); }  public static boolean equals(float x1,float y1,float z1,float x2,float y2,float z2) {  int prec=4;  if((int)x1*100==(int)x2*100 &&  		(int)y1*100==(int)y2*100 &&  		(int)z1*100==(int)z2*100) return true;  //  if(x1==x2 && y1==y2 && z1==z2) return true;/*  if(Toolkit.floatPrec(x1)==Toolkit.floatPrec(x2) &&     Toolkit.floatPrec(y1)==Toolkit.floatPrec(y2) &&     Toolkit.floatPrec(z1)==Toolkit.floatPrec(z2)) return 1;/*  Vec3DF v=new Vec3DF(x2-x1,y2-y1,z2-z1);  if(v.length()<0.01) {   System.out.println("v.length() ="+Str.numStr(v.length(),4)+" <"+Str.numStr(x1,4)+","+    Str.numStr(y1,4)+","+Str.numStr(z1,4)+"> <"+Str.numStr(x2,4)+","+Str.numStr(y2,4)+","+Str.numStr(z2,4)+">");   return 1;  }*/  return false; } public static boolean equals(Vec3 v1,Vec3 v2) {  return Vec3.equals(v1.x,v1.y,v1.z,v2.x,v2.y,v2.z); } public void rotateX(float deg) {  double sindeg,cosdeg;  double newy,newz;  sindeg=Math.sin(deg); cosdeg=Math.cos(deg);  newy=y*cosdeg-z*sindeg;  newz=y*sindeg+z*cosdeg;  y=(float)newy;  z=(float)newz; } public void rotateY(float deg) {  double sindeg,cosdeg;  double newx,newz;  sindeg=Math.sin(deg); cosdeg=Math.cos(deg);  newx=x*cosdeg-z*sindeg;  newz=x*sindeg+z*cosdeg;  x=(float)newx;  z=(float)newz; } public void rotateZ(float deg) {  double sindeg,cosdeg;  double newy,newx;  sindeg=Math.sin(deg); cosdeg=Math.cos(deg);  newx=x*cosdeg-y*sindeg;  newy=x*sindeg+y*cosdeg;  x=(float)newx;  y=(float)newy; } /**  * Calculates Cartesian point given a polar coordinate.  * a=0 is at the <0,-1,0> position, a=PI/2 is at <0,0,1>.  * b=0 is at the <-1,0,0> position, b=PI/2 is at <0,0,-1>  * @param a Angle 1  * @param b Angle 2  * @param R Radius  * @return Vec3 object containing the Cartesian point represented by the polar coordinates.  */ public static Vec3 fromPolar(float a,float b,float R) {  double sina,cosa,sinb,cosb;  sina=Math.sin(a); cosa=Math.cos(a);  sinb=Math.sin(b); cosb=Math.cos(b);  return new Vec3((float)(R*sina*sinb),(float)(R*cosa),(float)(R*sina*cosb)); } public static Vec3 fromPolar(Vec3 v) {  return Vec3.fromPolar(v.x,v.y,v.z); }}