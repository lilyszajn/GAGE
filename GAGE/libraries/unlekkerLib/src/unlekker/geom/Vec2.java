package unlekker.geom;import unlekker.util.Str;/** * <p>2D vector class.</p>  * @author <a href="http://workshop.evolutionzone.com/">Marius Watz</a> */public class Vec2 {	public static final float DEG=(3.14159265358979323846f/180.0f),			RADIAN=180.0f/3.14159265358979323846f;	/**	 * Position	 */	public float x, y;	/**	 * Constructs a vector with x=0, y=0.	 *	 */	public Vec2() {		x=0;		y=0;	}	/**	 * Constructs a vector with x=_x, y=_y.	 *	 */	public Vec2(float _x, float _y) {		this.x=_x;		this.y=_y;	}	/**	 * Constructs a vector with x=v.x, y=v.y.	 *	 */	public Vec2(Vec2 v) {		this.x=v.x;		this.y=v.y;	}/** *	Sets vector to the values of v.   * @param v */	public void set(Vec2 v) {		x=v.x;		y=v.y;	}	/**	 *	Sets vector to x = tx, y=ty.  	 * @param tx, ty	 */	public void set(float tx, float ty) {		x=tx;		y=ty;	}	public String toString() {		String s;		s=new String(""+Str.numStr(x)+" "+Str.numStr(y)				+"");		return s;	}	/**	 * Adds vector v to this vector. x = x + v.x, y = y + v.y	 * @param v	 */	public void add(Vec2 v) {		x+=v.x;		y+=v.y;	}	/**	 * Adds vx,vy to this vector. x = x + vx, y = y + vy	 * @param vx, vy	 */	public void add(float vx, float vy) {		x+=vx;		y+=vy;	}	/**	 * Subtracts vector v from this vector. x = x - v.x, y = y - v.y	 * @param v	 */	public void sub(Vec2 v) {		x-=v.x;		y-=v.y;	}	/**	 * Subtracts vx,vy from this vector. x = x - vx, y = y - vy	 * @param vx, vy	 */	public void sub(float vx, float vy) {		x-=vx;		y-=vy;	}	/**	 * Multiplies values of current vector with values of vector v.	 * x = x * v.x, y = y*v.y	 * @param v	 */	public void mult(Vec2 v) {		x*=v.x;		y*=v.y;	}	/**	 * Multiplies values of vx,vy with values of vector v.	 * x = x * vx, y = y*vy	 * @param vx,vy	 */	public void mult(float vx, float vy) {		x*=vx;		y*=vy;	}	/**	 * Scales current vector by single scaling factor m.	 * x = x * m, y = y* m	 * @param m	 */	public void mult(float m) {		x*=m;		y*=m;	}	/**	 * Divides the values of current vector by the float d.	 * x = x / d, y = y / d	 * @param m	 */	public void div(float d) {		x/=d;		y/=d;	}	/**	 * Normalizes the current vector to be 1 unit in length.	 *	 */	public void norm() {		float l;		l=length();		if (l>0) {			x/=l;			y/=l;		}	}	/**	 * Normalizes the current vector to be m units in length.	 *	 */	public void norm(float m) {		float l;		l=length();		if (l>0) {			x/=l;			y/=l;		}		x*=m;		y*=m;	}	/**	 * Returns distance between the point given by x,y and the point given by v.x, v.y. 	 * @param v Point to compare with	 * @return distance	 */	public float findDistance(Vec2 v) {		float xd, yd;		xd=v.x-x;		yd=v.y-y;		return (float)Math.sqrt(xd*xd+yd*yd);	}	/**	 * Returns distance between the point given by x,y and the point given by _x, _y. 	 * @param _x X position to compare with	 * @param _y Y position to compare with	 * @return distance	 */	public float findDistance(float _x, float _y) {		_x-=x;		_y-=y;		return (float)Math.sqrt(_x*_x+_y*_y);	}	/**	 * Returns the orientation (angle) of the vector in radians. This is a static version, 	 * which can be called without instantiating the class: 	 * 	 * float angle=Vec2.angle(50,100);	 * 	 * @param x	 * @param y	 * 	 * @return The orientation (angle) of the vector in radians.	 */	static public float angle(float x, float y) {		/*		 * float x,y; x=v.x/v.length(); y=v.y/v.length();		 */		return (float)Math.atan2(y, x)*RADIAN;	}	/**	 * Returns the orientation (angle) of the current vector in radians.	 * 	 * @return The orientation (angle) of the current vector in radians.	 */	public float angle() {		return (float)Math.atan2(y, x)*RADIAN;	}	/**	 *	Ccalculates intersection and checks for parallel lines.	 * Also checks that the intersection point is actually on the line segment p1-p2	 * 	 * @param p1 First point of first line	 * @param p2 Second point of first line	 * @param p3 First point of first line	 * @param p4 Second point of first line	 * @return Point of intersection if found, null if not found.	 */	public static Vec2 findIntersection(Vec2 p1, Vec2 p2, Vec2 p3, Vec2 p4) {		float xD1, yD1, xD2, yD2, xD3, yD3;		float dot, deg, len1, len2;		float segmentLen1, segmentLen2;		float ua, ub, div;		// calculate differences		xD1=p2.x-p1.x;		xD2=p4.x-p3.x;		yD1=p2.y-p1.y;		yD2=p4.y-p3.y;		xD3=p1.x-p3.x;		yD3=p1.y-p3.y;		// calculate the lengths of the two lines		len1=(float)Math.sqrt(xD1*xD1+yD1*yD1);		len2=(float)Math.sqrt(xD2*xD2+yD2*yD2);		// calculate angle between the two lines.		dot=(xD1*xD2+yD1*yD2); // dot product		deg=dot/(len1*len2);		// if abs(angle)==1 then the lines are parallell,		// so no intersection is possible		if (Math.abs(deg)==1)			return null;		// find intersection Pt between two lines		Vec2 pt=new Vec2(0, 0);		div=yD2*xD1-xD2*yD1;		ua=(xD2*yD3-yD2*xD3)/div;		ub=(xD1*yD3-yD1*xD3)/div;		pt.x=p1.x+ua*xD1;		pt.y=p1.y+ua*yD1;		// calculate the combined length of the two segments		// between Pt-p1 and Pt-p2		xD1=pt.x-p1.x;		xD2=pt.x-p2.x;		yD1=pt.y-p1.y;		yD2=pt.y-p2.y;		segmentLen1=(float)Math.sqrt(xD1*xD1+yD1*yD1)				+(float)Math.sqrt(xD2*xD2+yD2*yD2);		// calculate the combined length of the two segments		// between Pt-p3 and Pt-p4		xD1=pt.x-p3.x;		xD2=pt.x-p4.x;		yD1=pt.y-p3.y;		yD2=pt.y-p4.y;		segmentLen2=(float)Math.sqrt(xD1*xD1+yD1*yD1)				+(float)Math.sqrt(xD2*xD2+yD2*yD2);		// if the lengths of both sets of segments are the same as		// the lenghts of the two lines the point is actually		// on the line segment.		// if the point isn't on the line, return null		if (Math.abs(len1-segmentLen1)>0.01||Math.abs(len2-segmentLen2)>0.01)			return null;		// return the valid intersection		return pt;	}	/**	 * Calculates dot product of two vectors v1 and v2. 	 * @return dot product	 */	static public float dot(Vec2 v1, Vec2 v2) {		return v1.x*v2.x+v1.y*v2.y;	}	/**	 * Calculates length of vector.	 * @return length in units	 */	public float length() {		return (float)Math.sqrt(x*x+y*y);	}	/**	 * Calculates length of vector. Static version, can be called without instantiating an object.	 * @return length in units	 */	public static float length(float x, float y) {		return (float)Math.sqrt(x*x+y*y);	}	/**	 * Rotates vector by a degree given in radians 	 * @param radians Degree to rotate by, in radians.	 */	public void rotate(float radians) {		// Floats are not precise enough, so doubles are used for the calculations		if (radians==0)			return;		double cosval=Math.cos(radians);		double sinval=Math.sin(radians);		double tmpx=x*cosval-y*sinval;		double tmpy=x*sinval+y*cosval;		x=(float)tmpx;		y=(float)tmpy;	}	/**	 * Rotates vector by a degree given in radians. Static version. 	 * @param radians Degree to rotate by, in radians.	 */	public static Vec2 rotate(Vec2 v1, float deg) {		// Floats are not precise enough, so doubles are used for the calculations		if (deg==0)			return new Vec2(v1);		double cosval=Math.cos(deg*DEG);		double sinval=Math.sin(deg*DEG);		return new Vec2((float)(v1.x*cosval-v1.y*sinval), (float)(v1.x*sinval+v1.y				*cosval));	}}